# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15g_OX0UuXDz4JDoqo0a5CWpI8ghwexco
"""

!pip install tensorflow transformers
!pip install faiss-cpu

import os
import nest_asyncio
import logging
import datetime
import faiss
import torch
from sqlalchemy import create_engine, Column, Integer, String, LargeBinary, Sequence
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from transformers import ViTImageProcessor, ViTForImageClassification
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from PIL import Image

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Настройка базы данных
Base = declarative_base()

class Pet(Base):
    __tablename__ = 'pets'
    id = Column(Integer, Sequence('pet_id_seq'), primary_key=True)
    photo_path = Column(String)
    location = Column(String)
    embedding = Column(LargeBinary)
    owner_id = Column(Integer)
    is_found = Column(Integer)  # 0 - потерян, 1 - найден

# Создание базы данных SQLite и таблиц
engine = create_engine('sqlite:///pets.db', echo=True)
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

# Загрузка модели для классификации и извлечения эмбеддингов
processor = ViTImageProcessor.from_pretrained('google/vit-base-patch16-224')
model = ViTForImageClassification.from_pretrained('google/vit-base-patch16-224')

# Настройка FAISS для поиска похожих эмбеддингов
dimension = 768  # Размер эмбеддинга для ViT-base-patch16
index = faiss.IndexFlatL2(dimension)

# Функция извлечения эмбеддингов изображения
def get_image_embedding(image_path):
    image = Image.open(image_path)
    inputs = processor(images=image, return_tensors="pt")
    with torch.no_grad():
        outputs = model(**inputs)
    return outputs.last_hidden_state.mean(dim=1).numpy()  # Средний вектор для извлечения эмбеддинга

# Основной запуск бота
async def main():
    token = "xxxxxxxx"  # Вставьте здесь ваш токен
    application = Application.builder().token(token).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    application.add_handler(CommandHandler("delete", delete_photo))

    await application.run_polling()

# Команда /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("Я нашел питомца", callback_data="found_pet")],
        [InlineKeyboardButton("Я потерял питомца", callback_data="lost_pet")],
        [InlineKeyboardButton("Посмотреть фото найденных питомцев", callback_data="view_found")],
        [InlineKeyboardButton("Посмотреть фото потерявшихся питомцев", callback_data="view_lost")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Добро пожаловать! Выберите опцию:", reply_markup=reply_markup)

# Функция обработки фото
async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    photo_file = await update.message.photo[-1].get_file()
    photo_path = f"{user.id}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}.jpg"

    await photo_file.download(photo_path)
    embedding = get_image_embedding(photo_path)

    is_found = context.user_data.get("action") == "found_pet"

    pet = Pet(photo_path=photo_path, location="Координаты не указаны",
              embedding=embedding.tobytes(), owner_id=user.id, is_found=int(is_found))

    session = Session()
    session.add(pet)
    session.commit()
    index.add(embedding)

    await update.message.reply_text("Фото питомца сохранено.")

    if not is_found:
        similar_pets = find_similar_pets(embedding)
        if similar_pets:
            await notify_owner_with_similar_photos(update, similar_pets)

# Функция поиска похожих изображений
def find_similar_pets(embedding, top_k=5, threshold=0.8):
    distances, indices = index.search(embedding, top_k)
    similar_pets = []
    session = Session()
    for i, distance in enumerate(distances[0]):
        if distance < threshold:
            pet = session.query(Pet).get(indices[0][i])
            if pet and pet.is_found == 1:
                similar_pets.append(pet)
    return similar_pets

# Отправка сообщений с похожими фото
async def notify_owner_with_similar_photos(update: Update, similar_pets):
    for pet in similar_pets:
        with open(pet.photo_path, 'rb') as photo:
            await update.message.reply_photo(photo, caption=f"Похожий питомец найден! Место: {pet.location or 'Не указано'}")

# Функция удаления фото питомца
async def delete_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    pet_id = context.user_data.get("pet_id_to_delete")

    session = Session()
    pet = session.query(Pet).get(pet_id)

    if pet and pet.owner_id == user.id:
        session.delete(pet)
        session.commit()
        await update.message.reply_text("Фото питомца успешно удалено.")
    else:
        await update.message.reply_text("Ошибка: Питомец не найден или вы не являетесь владельцем.")

# Запуск бота
nest_asyncio.apply()
import asyncio
asyncio.run(main())
